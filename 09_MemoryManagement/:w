#include "paging.h"

#include "util.h"

void init_paging(void) {
    uint64_t * pml4t;
    asm ("mov %%cr3, %0" : "=a" (pml4t));

    // stage2 has already set up 4 Mibs of ID-mapped memory for the kernel, we only set up the HEAP

    uint16_t heap_pml4t_index = (HEAP_VIRT >> 39) & 0x1FF;
    uint16_t heap_pdpt_index  = (HEAP_VIRT >> 30) & 0x1FF;
    uint16_t heap_pdt_index   = (HEAP_VIRT >> 21) & 0x1FF;

    uint64_t * pdpt = (uint64_t *)(pml4t[heap_pml4t_index] & ~0x1FF);
    uint64_t * pdt = (uint64_t *) HEAP_PAGETABLES_START;

    if (!(pml4t[heap_pml4t_index] & 1)) { // Do we need a new PDPT?
        pml4t[heap_pml4t_index] = HEAP_PAGETABLES_START | HEAP_FLAGS;
        pdpt = (uint64_t *)HEAP_PAGETABLES_START;
        pdt += 0x1000 / 8;
    }

    size_t pdts = (heap_pdt_index + HEAP_PTS)/512; // How many PDTs will we need, at least? (we need to enter them into the PDPT) (offset because there might be overlaps with our heap being only e.g. only 1 PDT long, but start at one and ending at the next one somewhere in the middle, whoa, this comment is way to fucking long)
    if ((heap_pdt_index + HEAP_PTS) % 512)
        pdts += 1;

    for (size_t i = 0; i < pdts; i++) {
        pdpt[heap_pdpt_index + i] = (HEAP_PAGETABLES_START + 0x1000 * i) | HEAP_FLAGS;
    }

    for (size_t i = 0; i < HEAP_PTS; i++) {
        pdt[heap_pdt_index + i] = (HEAP_PHYS + 512 * 0x1000 * i) | HEAP_FLAGS | PAGE_PS;
    }

    asm ("mov %0, %%cr3" : : "a" (pml4t));
}
